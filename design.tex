\chapter{Τύποι επιθέσεων - Αντιμετώπιση με RT-IOT}\label{ch:design}

\section{Επιθέσεις στο Διαδίκτυο των πραγμάτων}

Όπως αναφέρθηκε στο Κεφάλαιο \ref{ch:bkg} ένας από τους κινδύνους παραβίασης της ασφάλειας του Κοινωνικού Διαδικτύου των Πραγμάτων πηγάζει από επιθέσεις κακόβουλων οντοτήτων οι οποίες όμως νομίμως δρουν εντός της κοινωνίας των πραγμάτων. Σε αυτό το κομμάτι του κεφαλαίου θα αναλύσουμε τις βασικότερες επιθέσεις που μπορούν να συμβούν.

\subsection{Μεμονωμένες κακόβουλες Εικονικές Οντότητες}\label{sec:indv}

Οι μεμονωμένες κακόβουλες Εικονικές Οντότητες Σχ.\ref{fig:individual.png} είναι o απλούστερος και ο βασικότερος τύπος επίθεσης. Σε αυτήν την περίπτωση ένα ποσοστό των μελών της κοινότητας έχοντας κακόβουλους σκοπούς προσπαθούν να εκμεταλλευτούν την εμπιστοσύνη των υπόλοιπων και όταν τους ζητηθεί κάποια υπηρεσία ή γνώση αντί να τους εξυπηρετήσουν σωστά στέλνουν δεδομένα που θα οδηγήσουν στο να εκτεθεί ο παραλήπτης σε κίνδυνο ή να οδηγηθεί σε δυσλειτουργία. 

\diagramscale{Μεμονωμένες κακόβουλες Εικονικές Οντότητες}{individual.png}{0.45}
\newpage
Η ύπαρξη κακόβουλων Εικονικών Οντοτήτων αποτελεί την βάση όλων των επιθέσεων και ο εντοπισμός τους είναι ο κύριος στόχος του RT-IOT. Για να βρεθούν χρειάζεται η συλλογική συμφωνία του συστήματος στο ποιες ακριβώς είναι.

Αλλά ακόμα και αν δεν τους εντοπίσει το σύστημα ώστε να σταματήσει να τους προτείνει ως πιθανούς φίλους με καλή φήμη, τα μέλη μπορούν αυτόνομα να προστατευθούν. Έτσι μετά από έναν αριθμό αλληλεπιδράσεων μία Εικονική Οντότητα θα χάσει την όποια εμπιστοσύνη τους στον κακόβουλο δράστη και θα τον απορρίψει από τον κοινωνικό του περίγυρο. Το θέμα είναι πόσο γρήγορα θα το κάνει ώστε να περιορίσει του κινδύνους.



\subsection{Συνεργαζόμενες κακόβουλες Εικονικές Οντότητες}\label{sec:col}

Σε αυτού του είδους της επίθεσης Σχ. \ref{fig:collusion.png} υπάρχει ένας αριθμός κακόβουλων Εικονικών Οντοτήτων όπως περιγράφηκε στην παράγραφο \ref{sec:indv} οι οποίες όμως τώρα έχουν γνώση (μερική ή ολική) για την ύπαρξή και άλλον κακόβουλων Εικονικών Οντοτήτων. Με αυτή λοιπόν την γνώση συνεργάζονται μεταξύ τους και όταν στέλνουν, είτε στην κεντρική αρχή είτε σε άλλα μέλη της κοινότητας, πληροφορίες για να εξαχθεί ο δείκτης φήμης παραποιούν τα δεδομένα τους και να παρουσιάζουν τους κακόβουλους συνεργάτες τους ως φερέγγυους.

\diagramscale{Συνεργαζόμενες κακόβουλες Εικονικές Οντότητες}{collusion.png}{0.35}

Αυτού του είδους η επίθεση είναι πολύ πιο επικίνδυνη από την προηγούμενη. Αυτό συμβαίνει επειδή δεν είναι δυνατόν να βασιστούν οι Εικονικές Οντότητες στην καλή θέληση των μελών της κοινωνίας για να εξαχθεί η φήμη αφού υπάρχει μεγάλη πιθανότητα να ψεύδονται για τις εμπειρίες τους. Για την αντιμετώπιση του πρέπει: \begin{itemize}
\item Στην περίπτωση της κεντρικής αρχής να εντοπιστεί όλη η κοινότητα των κακόβουλων δραστών και να σταματήσει να λαμβάνεται υπόψιν η γνώμη τους κατά την εξαγωγή φήμης.

\item Στην περίπτωση συστημάτων χωρίς κεντρική αρχή πρέπει η κάθε Εικονική Οντότητα να εντοπίσει κάποιου έμπιστους φίλους των οποίων η πιθανότητα να ψεύδονται για τις εμπειρίες τους θα είναι μειωμένη σε σχέση με το σύνολο και να εμπιστεύεται αυτούς για να εξάγει φήμη ενώ να αδιαφορεί για την γνώμη τον άλλον ή έστω να μην την λαμβάνει υπόψιν πάντα  (Παρ. \ref{sec:calculate_rep})
\end{itemize}

Μια εξελιγμένη μορφή αυτής της επίθεσης είναι η κακόβουλες Εικονικές Οντότητες να προσπαθούν να εντοπίσουν μέσω τις φήμης ανταγωνιστικές, προς τις υπηρεσίες που εκμεταλλεύονται, Εικονικές Οντότητες και να προσπαθήσουν να χαμηλώσουν την φήμη αυτών των Ε.Ο. με περαιτέρω ψευδής δηλώσεις για την εμπειρία τους με αυτές.

\subsection{Μερικώς κακόβουλες Εικονικές Οντότητες}\label{sec:part}

Σε αυτού του είδους την επίθεση Σχ. \ref{fig:partially.png} υπάρχουν κακόβουλες συνεργασίες όπως αναφέρθηκαν στην παράγραφο \ref{sec:col}. Η διαφορά τώρα όμως είναι πώς αυτές οι οντότητες προσπαθούν να νικήσουν το σύστημα φήμης αλλάζοντας την συμπεριφορά τους. Αυτό μπορεί να συμβεί με 2 τρόπους: 
\begin{enumerate}

\item Αρχικά μπορούν να παρέχουν κακές υπηρεσίες μόνο $ p \ \%  $ των περιπτώσεων ώστε να μην καταποντίζεται η φήμη τους. Δηλαδή μόλις δουν ότι υπάρχει μία κίνηση αποκλεισμού τους, να γίνονται καλές ώστε να παραμείνουν ενσωματωμένες. Σε αυτή την περίπτωση πρέπει το σύστημα που υπολογίζει την φήμη να έχει μνήμη ώστε να βλέπει καχύποπτα τέτοιου είδους συμπεριφορές και να εφαρμόζει αποκλεισμό με το που ξαναγίνουν κακόβουλες. Παρόλα αυτά αυτή η επίθεση δεν είναι τόσο επικίνδυνη επειδή η κακή συμπεριφορά της Εικονικής Οντότητας είναι φραγμένη από το $p$

\item Ένας άλλος τρόπος να ξεγελάσουν το σύστημα είναι να προσθέσουν στο ενεργητικό τους και άλλες υπηρεσίες. Έτσι θα είναι πιο εύκολο να εκμεταλλεύονται μία υπηρεσία για τους κακόβουλους σκοπούς τους αλλά να παραμένουν στο απυρόβλητο από το σύστημα φήμης επειδή παρέχουν άλλες καλά. Για να αντιμετωπιστεί αυτού του είδους η επίθεση πρέπει να υπάρχει διαφοροποίηση των δεικτών φήμης ανά υπηρεσία. Αλλά για να μπορέσει παραμείνει κλιμακώσιμο πρέπει να γίνει ομαδοποίηση σε παρόμοιες υπηρεσίες ώστε να περιοριστεί το εύρος που μπορεί να εκμεταλλευτεί μία κακόβουλη Εικονική Οντότητα χωρίς να κοστίζει πολύ στο σύστημα.
\end{enumerate}

\diagramscale{Μερικώς κακόβουλες Εικονικές Οντότητες}{partially.png}{0.3}
\newpage
\subsection{Κακόβουλοι κατάσκοποι}\label{sec:spies}

Αυτού του είδους η επίθεση  Σχ. \ref{fig:spies.png} είναι βοηθητική στις \ref{sec:col} και \ref{sec:part}. Οι Εικονικές Οντότητες - κατάσκοποι. Ονομάστηκαν έτσι επειδή στα μάτια του μεγαλύτερου μέρους των μελών του συστήματος παρουσιάζονται ως αξιόπιστες. Αυτό το καταφέρνουν παρέχοντας πάντα μία υπηρεσία καλά. Έτσι αυξάνουν την φήμη τους και την εμπιστοσύνη μεμονωμένων Εικονικών Οντοτήτων προς αυτές. Αυτό όμως που τις κάνει κακόβουλες είναι η συμπεριφορά τους όταν τους ζητηθεί αξιολόγηση ή να προτείνουν κάποιον άλλον πάροχο διαφορετικής υπηρεσίας. Τότε συνεργαζόμενοι με τις κακόβουλες κοινότητες του συστήματος ψεύδονται για τις εμπειρίες τους και προτείνουν κακόβουλες οντότητες για φίλους.

Ένα σύστημα που αντιμετωπίζει όλες τις παραπάνω επιθέσεις δεν μπορεί να αντιμετωπίσει και αυτήν. Για να γίνει αυτό πρέπει να υπάρξει αποσύνδεση της εμπιστοσύνης σε κάποιον ως πάροχο υπηρεσίας, από την εμπιστοσύνη ως πάροχο πληροφοριών. Με αυτόν τον τρόπο θα κρατάμε τους κατασκόπους για να μας παρέχουν σωστές υπηρεσίες αλλά η φήμη της ως παρόχους πληροφοριών θα είναι χαμηλή και άρα δεν θα λαμβάνετε υπόψιν.

\diagramscale{Κακόβουλοι κατάσκοποι}{spies.png}{0.5}

\newpage 

\subsection{Sybil attack}\label{sec:sybil}

Σε αυτήν την επίθεση  Σχ. \ref{fig:sybil.png} κάποιος καταφέρνει να δημιουργήσει ένα τεράστιο αριθμό εικονικών οντοτήτων και να τις χρησιμοποιήσει για τους κακόβουλους σκοπούς τους. Μόλις μειωθεί η φήμη τους τις διαγράφει και κάνει νέες. Για την αντιμετώπισή του πρέπει: \begin{enumerate}

\item Αρχικά να μην υπάρχει πλεονέκτημα σε μία νέα οντότητα σε σχέση με κάποια με χαμηλή φήμη. Αυτό επιτυγχάνετε με την απουσία αρνητικής βαθμολογίας. Έτσι μία νέα οντότητα αντιμετωπίζεται με καχυποψία και θα πρέπει να αποδείξει την αξία της για να ενσωματωθεί

\item Ακόμα πρέπει να υπάρχει ένα ελάχιστο κόστος για την δημιουργία νέων εικονικών οντοτήτων. Στο σύστημα μας προτείνετε να πρέπει ο χρήστης να συνδέσει την οντότητα του με κάποιο user-id. Το οποίο να μην γίνετε αυτόματα (π.χ χρήση Captcha)

\end{enumerate}

\diagramscale{Sybil attack}{sybil.png}{0.3}

\subsection{Ψευδής δήλωση στοιχείων}

Στον Ατζορι έχει προταθεί ο πολλαπλασιασμός τις εμπιστοσύνης σε κάποιον με ένα βάρος για το πόσο εύκολο είναι για αυτόν να συμπεριφερθεί κακόβουλα. Έτσι αναφέρεται ότι θα εμπιστευτεί μία οντότητα πιο εύκολα εάν έχει χαμηλή υπολογιστική ισχύ π.χ. RFID  από μία ισχυρή όπως ένα smartphone. Αλλά είναι δυνατόν κάποιος είτε να ισχυριστεί πώς είναι οντότητα διαφορετικού τύπου από την πραγματικότητα \footnote{ το οποίο ίσως να μπορούσε να ελεγχθεί μέσα από προσπάθεια εντοπισμού των ενεργειών της οντότητας, το οποίο είναι δύσκολο χωρίς κεντρική αρχή που βλέπει όλες τις συναλλαγές}, είτε να έχει τον έλεγχο πραγματικών οντοτήτων τύπου RFID που θα είναι εύκολο να γίνουν έμπιστες και θα τις εκμεταλλεύεται. 

Για αυτό εμείς αντιπροτείνουμαι το βάρος να είναι ανάλογα με το πόσο επικίνδυνο θα ήταν για μία Εικονική Οντότητα να παραπλανηθεί για μία συγκεκριμένη υπηρεσία. Έτσι υπηρεσίες που θα μπορούσε να δώσει ενα RFID  που πιθανώς να ήταν ήσσονος σημασίας θα ζητούνται ακόμα και από Οντότητες μέτριας εμπιστοσύνης, ενώ κρίσιμες υπηρεσίας θα ζητούνται από έμπιστους παρόχους. Το πώς μοντελοποιήθηκε αυτό το βάρος φαίνεται στο ΡΕΦ παρακάτω.
\newpage

\section{RT-IOT}
\subsection{Εισαγωγή}
To RT-IOT (Reputation \& Trust for the Internet Of Things) είναι ένα σύστημα που προτείνουμε για την αντιμετωπίσει των παραπάνω επιθέσεων στο περιβάλλον του Κοινωνικού Διαδικτύου των Πραγμάτων. Ο βασικός στόχος του ήταν να μπορεί να παρέχει μία αποτελεσματική άμυνα προς τις εσωτερικές επιθέσεις, παρέχοντας ταυτόχρονα την δυνατότητα εισόδου και εξόδου Εικονικών Οντοτήτων στο σύστημα 
και λαμβάνοντας υπόψιν των μεγάλο αριθμό Εικονικών Οντοτήτων που θα πρέπει να διαχειριστεί.

Για να δημιουργηθεί ένα τέτοιο σύστημα η βασική σχεδιαστική απόφαση έγκειται στο γεγονός ότι δεν είναι δυνατόν αυτό να γίνει ούτε με μία κεντρική αρχή ούτε κατανεμημένα, εάν η φήμη μίας Εικονικής Οντότητας ήταν ίδια για όλο το σύστημα, όπως συμβαίνει στα περισσότερα συστήματα εμπιστοσύνης/φήμης. Έπρεπε να εγκαταλειφθεί η ιδέα της "αντικειμενικής αλήθειας" για την φήμη του άλλου. Για αυτό κοιτάξαμε την κοινωνία όπου όχι μόνο δεν γνωρίζουμε την φήμη όλων των μελών της αλλά αγνοούμε ακόμα και την ύπαρξη τους.

Με αυτόν τον περιορισμό ως θεμέλιο λίθο χτίσαμε ένα σύστημα με ανοχή σε σφάλματα όπου συνδυάζει ιδέες τόσο από συστήματα με κεντρική αρχή όσο και από συστήματα με κατανεμημένη λογική.

\subsection{Υπολογισμός Εμπιστοσύνης}\label{sec:calculate_trust}
Όπως φαίνεται και από στον ορισμό της στην Παρ. \ref{sec:trust}, η εμπιστοσύνη είναι υποκειμενική. Για αυτό και είναι λογικό να ορίζεται και να διαφέρει για κάθε Εικονική Οντότητα.

Για να μοντελοποιήσουμε την εμπιστοσύνη χρειάζεται να μοντελοποιηθεί η εμπειρία. Άρα χρειαζόμαστε μνήμη. Για αυτό κάθε Εικονική Οντότητα έχει log files όπου αποθηκεύει της εμπειρίες των αλληλεπιδράσεών της με άλλες Ε.Ο. Εδικότερα όπως αναφέραμε στην παράγραφο \ref{sec:part} πρέπει να έχουμε διαφορετικά log file για διαφορετικά είδη υπηρεσιών (π.χ. άλλο Log File για υπηρεσίες στο domain "home automation" ,αλλο  στο domain "vehicles" και άλλα για ανταλλαγή γνώσης). Επίσης για γρηγορότερους και ευκολότερους υπολογισμούς δέν έχουμε ένα log file ανα υπηρεσία, αλλά ένα ανά οντότητα εντός της υπηρεσία.

Επιπρόσθετα, ειδική μέριμνα πρέπει να υπάρξει για την αποσύνδεση της εμπιστοσύνης σε μία Εικονική Οντότητα για την παροχή υπηρεσιών από την παροχή προτάσεων για άλλους πιθανούς φίλους (recommendation). Αυτό έχει ως βασικό αίτιο το γεγονός ότι η παροχή συστάσεων είναι μία υποκειμενική πράξη που βασίζετε σε προσωπικά κριτήρια και δεν πρέπει να μπλέκεται με αντικειμενικές αλήθειες όπως το πόσο καλά παρέχει κάποιος μία υπηρεσία. Ως επακόλουθο αυτής τις πρακτικής θα υπάρχει και απόλυτη προστασία από την επίθεση της παραγράφου \ref{sec:spies}.

Άρα εάν μία Εικονική Οντότητα ζητάει την υπηρεσία "vehicle", όπου έχει γνωστούς για αυτή τον Β και τον Γ, και επίσης ζητάει και γνώση , όπου έχει γνωστούς για αυτή τον Β και τον Ε. Τα log file είναι όπως στο σχήμα \ref{fig:files.png}
\newpage
\diagramscale{Ιεραρχία Log File}{files.png}{0.4}


Σε κάθε εγγραφή του log file βάζουμε τις εξής στήλες:
\begin{itemize}

\item \textbf{Ικανοποίηση:} Είναι η βαθμολογία που εξάγει μία εικονική οντότητα για την ποιότητα της υπηρεσίας/γνώσης που έλαβε

\item \textbf{Βάρος:} Είναι μία τιμή που καταγράφει η εικονική οντότητα το πόσο κρίσιμη για αυτήν είναι η υπηρεσία που ζήτησε. Αυτή η τιμή χρησιμοποιείτε και για να ορίσει ένα κάτω όριο εμπιστοσύνης κατά την φάση αναζήτησης παρόχου. Επίσης το βάρος μπορεί να επηρεαστεί και από άλλους παράγοντες όπως εάν ανήκουν οι δύο οντότητες στον ίδιο χρήστη(co-ownership),εάν οι χρήστες γνωρίζονται από πρίν(friends), εάν βρίσκονται γεωγραφικά κοντά (co-location), εάν είναι ίδιου τύπου οντότητες (homophily) κ.α

\item \textbf{Εξασθένηση:} Αναγνωρίζοντας την ανάγκη οι νεότερες συναλλαγές να έχουν μεγαλύτερο βάρος από τις παλαιότερες εισάγουμε την έννοια του παράγοντα εξασθένησης (fading effect). Με αυτόν τον τρόπο αναγκάζουμε της Εικονικές οντότητες να έχουν συνεπή συμπεριφορά και να μην μπορούν να παρεκτραπούν εκμεταλλευόμενη την καλή τους ιστορία. Επίσης με τον δείκτη εξασθένισης καταφέρνουμε να κρατήσουμε το σύστημα κλιμακόσημο αφού κάθε Εικονική Οντότητα κρατάει μικρό log file.Τέλος παρέχουμε την δυνατότητα εξιλεώσεις σε κακόβουλες οντότητες αφού μετά από κάποιο χρονικό διάστημα η συμπεριφορά τους τότε θα ξεχαστεί και θα κυριαρχεί η νέα καλή τους φύση.

\end{itemize}

\begin{table}[H]
    \centering
    \begin{tabular}{ | l | l | l | }
        \hline
        Ικανοποίηση & Βάρος & Εξασθένηση \\ \hline \hline
        0.1 & 0.8 & 1.0  \\ \hline
        1.0 & 0.1 & 0.95  \\ \hline
        0.3 & 0.8 & 0.9  \\ \hline
        0.75 & 0.25 & 0.85  \\ \hline
    \end{tabular}
    \caption{Log File Εικονικής Οντότητας Α για της αλληλεπιδράσεις με την Β}
    \label{tab:log file}
\end{table}

\newpage
Όταν η Εικονική Οντότητα Α θέλει να υπολογίσει την εμπιστοσύνη της στην εικονική οντότητα Β για μία συγκεκριμένη υπηρεσία βρίσκει το κατάλληλο log file και μετά υπολογίζει την μέση τιμή της ικανοποίησης λαμβάνοντας υπόψιν το βάρος και τον παράγοντα εξασθένησης. Άρα 
\begin{equation}\label{eq:average}
 \mu_t^k\  =\ \frac{\sum_{i=1}^{N}\left(s_i\ *\ w_i\ *\ f_i\right)}{W} 
\end{equation}

όπου 
\begin{equation}\label{eq:weight}
 W = \sum_{i=1}^{N}\left(w_i\ *\ f_i\right)
\end{equation}

Το W είναι ο συντελεστής κανονικοποίησής και εξασφαλίζει ότι η μέση τιμή θα παραμείνει εντός του εύρους [0,1]. Η μέση τιμή (μ) είναι μία μέτρηση της ολικής συμπεριφοράς της Εικονικής Οντότητας και μας δείχνει πια είναι η πιθανότερη τιμή ικανοποίησης που θα πάρουμε ένα ζητήσουμε την υπηρεσία από τον συγκεκριμένο πάροχο.

Παρόλα αυτά θέλουμε να ξέρουμε και πόσο σίγουροι μπορούμε να είμαστε για την τιμή του μ. Δηλαδή πόσο μπορεί να αποκλίνει η ικανοποίηση της υπηρεσίας από το μ. Για αυτό υπολογίζουμε και την τυπική απόκλιση της συμπεριφοράς. Για να κάνουμε αρκετά λιγότερες πράξεις το κάνουμε με τον ακόλουθο τύπο ταυτόχρονα με τον υπολογισμός της μέσης τιμής.

\begin{equation}\label{eq:deviation}
 \sigma_t^k\  =\ \frac{1}{W} \sqrt{\sum_{i=1}^{N}\left(s_i^2\ *\ w_i\ *\ f_i\right)* \ \sum_{i=1}^{N} \left(w_i\ * \ f_i \right)- \left( \sum_{i=1}^{N} s_i\ *\ w_i\ *\ f_i\right)^2}
\end{equation}

Τέλος ορίζουμε την εμπιστοσύνη ως:

\begin{equation}\label{eq:trust}
 T^k \ = \ \mu_t^k \ - \sigma_t^k 
\end{equation}

Δηλαδή ,υποθέτοντας πώς η συμπεριφορά της ΕΟ ακολουθεί την κανονική κατανομή \footnote{μπορεί μέσα από στατιστική ανάλυση να βρεθεί η πραγματική κατανομή και να αλλαχθούν τα ποσοστά}, μπορούμε να πούμε ότι εάν ζητήσουμε την υπηρεσία από τον συγκεκριμένο πάροχο έχουμε κάτω από 15\% πιθανότητα να πάρουμε ικανοποίηση χαμηλότερη από Τ και άρα το ρίσκο είναι με το μέρος της Εικονικής Οντότητας.

\begin{table}[H]
    \centering
    \begin{tabular}{ | l | l | l | }
        \hline
        Σύμβολο & Περιγραφή \\ \hline \hline
        $s_i$ & Ικανοποίηση στην συγκεκριμένη συναλλαγή  \\ \hline
        $w_i$ & Βάρος στην συγκεκριμένη συναλλαγή  \\ \hline
        $f_i$ & Εξασθένηση της συγκεκριμένη συναλλαγή  \\ \hline
        $\mu_t^k$ 	& Μέση τιμή της εμπιστοσύνης στον k\\ \hline
        $\sigma_t^k$    & Τυπική απόκλιση της εμπιστοσύνης στον k \\ \hline
        $T^k$   & Εμπιστοσύνη στον k \\ \hline
            \end{tabular}
    \caption{Πίνακας συμβόλων για υπολογισμό εμπιστοσύνης}
    \label{tab:symbols_trust}
\end{table}
\newpage
\subsection{Υπολογισμός Φήμης}\label{sec:calculate_rep}
Στο RT-IOT η φήμη όπως αναφέραμε δεν υπολογίζεται ολικά για κάθε Εικονική Οντότητα. Δηλαδή εάν δύο εικονικές οντότητες έχουν η κάθε μια από ένα δείκτη φήμης για μία τρίτη Εικονική Οντότητα, τότε αυτές οι δύο τιμές δεν θα συμφωνούνε. Άρα και ο δείκτης φήμης είναι ατομική πληροφορία πού η κάθε Ε.Ο. διαθέτει. Παρόλα αυτά για να εξασφαλίσουμε ότι κάθε Εικονική Οντότητα θα μπορεί να εξάγει τον δείκτη φήμης μίας άλλης παρουσιάζουμε έναν μηχανισμό που έχει ανοχή σε σφάλμα/αποτυχία. Αυτό συμβαίνει επειδή η φήμη μπορεί να εξαχθεί με δύο ανεξάρτητους τρόπους. Δηλαδή:
\begin{enumerate}
\item \textbf{Κατανεμημένος τρόπος:} Όταν μία Ε.Ο. θέλει να βρει την φήμη μίας άλλης ακολουθεί την λογική των κατανεμημένων συστημάτων \ref{sec:decentralized}. Άρα οπως θα δούμε παρακάτω βασίζεται στον κοινωνικό της περίγυρο.

\item \textbf{Συγκεντρωτικός τρόπος:} Εάν αποτύχει ο πρώτος τρόπος η Ε.Ο. καταφεύγει σε μία κεντρική αρχή \ref{sec:centralized},  η οποίο γνωρίζει όλες της οντότητες του συστήματος αλλά έχει ένα πολύ μικρό δείγμα (partial view) των αλληλεπιδράσεων ώστε να μπορεί να κλιμακώσει το όλο σύστημα. Παρόλα αυτά έχει μία καλή ιδέα για το πόσο καλή είναι γενικά μία Ε.Ο.

\end{enumerate}

\subsubsection{Κατανεμημένος τρόπος Υπολογισμού Φήμης}
Όταν κάποιος έχει προταθεί έναν νέο φίλο πριν τον εμπιστευθεί προσπαθεί να υπολογίσει τον δείκτη φήμης του. Αυτό συμβαίνει σε δύο βήματα.

\textbf{Βήμα 1ο}: Εικόνα \ref{fig:rep_step_1.png} \\*
Η Εικονική Οντότητα(π.χ. η Α) βρίσκει τους 5 καλύτερους recommenders , δηλαδή αυτούς που εμπιστεύεται περισσότερο για να συστήσουν κάποιον και τους ρωτάει την εμπειρία τους με την Εικονική Οντότητα(Β) που θέλει να ακολουθήσει\footnote{Στο Cosmos ο φίλος ονομάζεται followee και άρα ακολουθείτε}, οι recommenders  με την σειρά τους γυρίζουν την εμπιστοσύνη τους σε αυτόν\footnote{Ο αναγνώστης μπορεί να προσέξει πώς δέν γυρνάμε το μ ή το σ αλλά το Τ=μ-σ, έτσι δυσκολεύουμε πιθανούς αντιπάλους από το να μας χειραγωγήσουν με τις υπηρεσίας που παρέχουν ώστε να έχουμε συγκεκριμένη εμπιστοσύνη}. Ο Α συλλέγει αυτές τις πληροφορίες και υπολογίζει μία \textit{ αρχική κατανομή φήμης } χρησιμοποιώντας πάλι τις εξισώσεις όπως οι \ref{eq:average},\ref{eq:weight},\ref{eq:deviation} όπου το βάρος είναι η εμπιστοσύνη του Α στον εκάστοτε recommender για την προσφορά συστάσεων. Έτσι έχουμε πάλι:

\begin{equation}\label{eq:rep_average}
 \mu_r^k\  =\ \frac{\sum_{i=1}^{N}\left( T_i^k\ *\ T_{rec}^i \right)}{W'} 
\end{equation}
και
\begin{equation}\label{eq:rep_deviation}
 \sigma_r^k\  =\ \frac{1}{W'} \sqrt{\sum_{i=1}^{N}\left( {T_i}^2\ *\ T_{rec}^i \right)* \ \sum_{i=1}^{N} \left(T_{rec}^i\right)- \sum_{i=1}^{N}\left( T_i^k\ *\ T_{rec}^i \right)^2}
\end{equation}

όπου 
\begin{equation}\label{eq:rep_weight}
 W' = \sum_{i=1}^{N}\left( T_{rec}^i \right)
\end{equation}

Και ορίζουμε τον δείκτη φήμης ως:

\begin{equation}\label{eq:reputation}
 R^k \ = \ \mu_r^k \ - \sigma_r^k 
\end{equation}



\diagramscale{Βήμα 1 για κατανεμημένο υπολογισμό φήμης}{rep_step_1.png}{0.5}
\textbf{Βήμα 2ο}: Εικόνα \ref{fig:rep_step_2.png} \\*
 Έχοντας λοιπόν την αρχική κατανομή της φήμης ($\mu_r^k$, $\sigma_r^k$) η Ε.Ο. συνεχίζει να ρωτά φίλους για την εμπειρία τους με τον Β μέχρι να μαζέψει έναν ικανό αριθμό από γνώμες. Αυτές όμως τις γνώμες δεν τις δέχεται άκριτα. Πρώτα προσπαθεί να αποκλείσει κακόβουλες προτάσεις. Στο αρχικό μοντέλο υποθέτουμε πώς και εδώ η συμπεριφορά ακολουθεί κανονική κατανομή οπότε το εύρος που θέλουμε να είναι μέσα η σύσταση ώστε να μην είναι κακόβουλη, είναι: [$\mu_r^k-0.7\sigma_r^k$,$\mu_r^k+0.7\sigma_r^k$]\footnote{το οποίο αντιστοιχεί στο 51\%  τής κατανομής}. Αλλά εκ των υστέρων μπορεί να γίνει στατιστική ανάλυση και αυτό να αλλάξει ώστε να γίνει πιο ακριβές.

Μετά συνεχίζουμε με των υπολογισμό της τελικής κατανομής βάζοντας τις νέες καλές συστάσεις στις σχέσεις \ref{eq:rep_average} - \ref{eq:reputation}  και όταν βγει η τελική κατανομή αξιολογούμε και τους αρχικούς recommenders του βήματος 1.




\diagramscale{Βήμα 2 για κατανεμημένο υπολογισμό φήμης}{rep_step_2.png}{0.55}

\begin{table}[H]
    \centering
    \begin{tabular}{ | l | l | l | }
        \hline
        Σύμβολο & Περιγραφή \\ \hline \hline
        $T_i^k$ & Εμπιστοσύνη του i στον k  \\ \hline
        $T_{rec}^i$ & Εμπιστοσύνη στον i για συστάσεις (recommendations) \\ \hline
        $\mu_r^k$ 	& Μέση τιμή της φήμης του k\\ \hline
        $\sigma_r^k$    & Τυπική απόκλιση της φήμης του k \\ \hline
        $R^k$   & Φήμη του k \\ \hline
            \end{tabular}
    \caption{Πίνακας συμβόλων για υπολογισμό φήμης}
    \label{tab:symbols_rep}
\end{table}
\subsubsection{Συγκεντρωτικός τρόπος Υπολογισμού Φήμης}

Για αυτό τον τρόπο υπολογισμού της φήμης δανειζόμαστε στοιχεία από τα συστήματα με κεντρική αρχή υπεύθυνη για τον υπολογισμό της φήμης (βλ. Παρ \ref{sec:centralized}). Στο σύστημά μας υπάρχει μια οντότητα η οποία στο CosmoS ονομάζεται πλατφόρμα και ένας από τους λόγους ύπαρξης της είναι να παρέχει δείκτες φήμης σε Ε.Ο. όταν ο κατανεμημένος τρόπος αποτυγχάνει( φίλους η Ε.Ο που να έχουν εμπειρία με την νέα Ε.Ο. υποψήφια για φίλο).

Πώς το κάνει όμως αυτό;

Η πλατφόρμα γνωρίζει όλες τις Εικονικές Οντότητες, για να παραμείνει όμως ικανή να διαχειριστεί των τεράστιο αριθμό των πραγμάτων δεν έχει ολική εικόνα των συναλλαγών μεταξύ Εικονικών Οντοτήτων. Αντίθετα για να εξάγει έναν δείκτη φήμης δέχεται σε τυχαίες χρονικές στιγμές feedback από τις Εικονικές Οντότητες σχετικά με τις εμπειρίες τους. Αυτό το feedback είναι απλά ο δείκτης εμπιστοσύνης μίας εικονικής οντότητας σε μία άλλη μαζί με τον αριθμό των αλληλεπιδράσεών τους. Έτσι χρησιμοποιώντας ως βάρος τον αριθμό των αλληλεπιδράσεων χρησιμοποιεί ίδιες σχέσης με αυτές για την εξαγωγή εμπιστοσύνης παραπάνω και βγάζει έναν δείκτη φήμης. Αυτό ο δείκτης δεν είναι απόλυτα σωστός αλλά μπορεί να δείξει την τάση της συμπεριφοράς μία Εικονικής Οντότητας.

Καλό είναι να σημειώσουμε πώς και αυτός ο μηχανισμός μπορεί να αποτύχει στον βαθμό ακρίβειας του. Έτσι η κοινότητα σε περίπτωση sybil attack \ref{sec:sybil} μεγάλου μεγέθους μαζί με συνεργασία των κακόβουλων οντοτήτων \ref{sec:col} θα δίνει σκόπιμα κατασκευασμένο feedback στην πλατφόρμα, η οποία θα θεωρεί πώς οι κακοί είναι καλοί και αντίστροφα. Παρακάτω θα δούμε πώς αυτό αντιμετωπίζεται  στην παράγραφο \ref{sec:friend_acquisition}.
\newpage
\section{Βασικά Σενάρια Χρήσης}

\subsection{Αίτηση παροχής Υπηρεσίας (Service Request)}\label{sec:ser_req}

Ο λόγος που δημιουργήθηκε το RT-IOT είναι για να βρίσκει μία Εικονική Οντότητα τον καλύτερο δυνατό πάροχο με βάση την δικιά της εικόνα για την κοινωνία και τις δικές της ανάγκες. Αυτό το καταφέρνει αποδοτικά με την χρήση των δεικτών εμπιστοσύνης και φήμης που αναλύθηκαν στην προηγούμενη ενότητα.

Όταν λοιπόν μία Εικονική Οντότητα αποφασίζει πώς χρειάζεται μία συγκεκριμένη υπηρεσία ξέρει και πόσο πρόθυμη είναι να ρισκάρει.\footnote{δηλαδή ο developer της έχει αποφασίσει ή σε πιο εξελιγμένο επίπεδο το κάνει μόνη της υπολογίζοντας πόσο θα της κοστίσει αν κάτι πάει στραβά} Αυτή την τιμή την χρησιμοποιεί ως κατώφλι(threshold) για την τιμή των δεικτών που υπολογίζει. Δηλαδή εάν δεν είναι πρόθυμη να ρισκάρει πολύ μπορεί να βάλει το κατώφλι 0.8 και άρα να ζητήσει την υπηρεσία μόνο από Εικονικές Οντότητες-φίλους που εμπιστεύεται τουλάχιστον κατά 0.8/1.0. Φυσικά η εύρεση αυτών μπορεί να είναι δυσκολότερη οπότε να χρειαστεί παραπάνω πόρους για να το επιτύχει και αυτό είναι ένα trade-off που πρέπει να ληφθεί υπόψιν κατά τον ορισμό του κατωφλίου.

Όταν λοιπόν οριστεί το κατώφλι αρχίζει η αναζήτηση κατάλληλου παρόχου. Αυτό μπορεί να γίνει με 2 διαφορετικούς τρόπους ανεξάρτητους μεταξύ τους
\subsubsection{1) Αίτηση σε Φίλο}

Ο πρώτος τρόπος που δοκιμάζει μία Εικονική Οντότητα να βρει έναν κατάλληλο πάροχο είναι να βρει κάποιον φίλο της που εμπιστεύεται αρκετά. Για να γίνει αυτό πάει στην κατάλληλη υπηρεσία (βλ. σχήμα \ref{fig:files.png}) και αποτιμά την εμπιστοσύνη της σε κάθε ένα από τους φίλους της. 

Εφόσον με κάποια εικονική οντότητα υπάρχει αρκετή προϊστορία συναλλαγών ( log file $> \  5$) τότε ο υπολογισμός της εμπιστοσύνης γίνεται δύο φορές ταυτόχρονα. Χρησιμοποιώντας της σχέσης \ref{eq:average} - \ref{eq:trust} υπολογίζεται το $T_{long}$ γιά $ N $ ίσο με το μέγεθος του log file και το $T_{short}$ για $N$ ίσο με $\frac{size \left(log\_file\right)}{10}$. Εδώ καλό είναι να αναφέρουμε πώς το log file είναι μορφής LIFO οπότε η πρώτη εγγραφή είναι και η κοντινότερη χρονικά. Στην συνέχεια θεωρούμε πώς: $$ T = min(T_{long} \  , \  T_{short})$$

Με αυτόν τον τρόπο η τιμή του  $T_{long}$ δείχνει την ολική εμπειρία μας με κάποια Ε.Ο. για αυτήν την υπηρεσία ενώ το $T_{short}$ δείχνει την συμπεριφορά της στις τελευταίες χρονικές στιγμές. Οπότε μπορούμε να τόσο να ανιχνεύσουμε την μεταβολή μίας καλόβουλης Ε.Ο. σε κακόβουλη γρήγορα ,αφού το $T_{short}$ θα μειωθεί ραγδαία, όσο και να μην ξεγελαστούμε από την ξαφνική καλοσύνη μίας κακόβουλης Ε.Ο. ,αφού το $T_{long}$  έχει αρκετή "αδράνεια" ώστε να το εμποδίσει. Έτσι αντιμετωπίζονται μερικώς κακόβουλες οντότητες 1ου τύπου (\ref{sec:part}).
\newpage
Αφού γίνει ο υπολογισμός των δεικτών εμπιστοσύνης της Ε.Ο. για όλους τους φίλους της στην συγκεκριμένη υπηρεσία, επιλέγει τον πιο έμπιστο φίλο και συγκρίνει τον δείκτη εμπιστοσύνης του με το κατώφλι. Εάν το ξεπερνάει τότε έχει βρεθεί μία αρκετά καλή λύση για το πρόβλημα της με ένα ικανοποιητικά χαμηλό ρίσκο, οπότε ζητάει την υπηρεσία. Εδώ καλό είναι να σημειώσουμε πώς εάν πληρούνται κάποιες προϋποθέσεις ασφαλείας \footnote{η υπηρεσία δεν είναι κρίσιμης σημασίας και δέν έχω κάποιον πολύ καλό πάροχο} τότε υπάρχει μία πιθανότητας 10\% να ζητηθεί η υπηρεσία από ένα φίλο που δεν έχω πολλές αλληλεπιδράσεις μαζί του (π.χ. μου τον έδωσε η πλατφόρμα χωρίς να υπάρχει δείκτης φήμης, άρα είναι κάποια Εικονική Οντότητα που μόλις εισηχθεί στο σύστημα). Αυτό συμβαίνει για να μπορούν να ενσωματωθούν δυναμικά στο σύστημα νέοι κόμβοι και να υπάρχει καταμερισμός εργασιών. 

Σε περίπτωση που αποτύχει ο πρώτος τρόπος και δέν βρεθεί κάποιος η Ε.Ο. προχωράει στον 2ο τρόπο. 

\begin{algorithm}
\caption{Service Request Method: Ask\_Friend}
\label{Service Request 1}
\begin{algorithmic}[1]
\Procedure{Ask\textendash Friend}{}
\State $Threshold = t$
\State $Best = 0$
\State $Trust = 0$


\For{each friend $i$ \Pisymbol{psy}{206} $Service$ }
\State log\_file=get\_log\_file(Service,i)

\If{size(log\_file) > 5}
\State $T_{short}=$caculate\_Trust(i,$\frac{size \left(log\_file\right)}{10}$)
   \Else \State $T_{short}=1.0$
   \EndIf
\State $T_{long}=$caculate\_Trust(i,$size \left(log\_file\right)$)
\State $ T = min(T_{long} \  , \  T_{short})$
\If{$T \ > \ Trust$}
	\State Best=i
	\State Trust=T
\EndIf
\EndFor
\If{ $Trust \geq threshold$}
	\State RequestService(Service,Best)
	\Else 
	\If{$\left(threshold \  indicates\  low\  severity\right)\  AND\ \left( Math.random() \leq 0.1\right)$}
			\State RequestService(Service,Random friendwith zero trust)
	\EndIf
\EndIf

\EndProcedure
\end{algorithmic}
\end{algorithm}
\newpage
\subsubsection{2) Αίτηση σε φίλο φίλου}

Αν δεν καταφέρει η εικονική οντότητα να βρει κάποιον έμπιστο γνωστό της πάροχο τότε θα στραφεί στους φίλους της. Ένας τρόπος να το κάνει αυτό είναι να υπολογίσει με τον ίδιο τρόπο τους δείκτες εμπιστοσύνης σε φίλους, όχι όμως για την συγκεκριμένη υπηρεσία αλλά για παροχή βοήθειας (assistance).

 Εάν λοιπόν υπάρχουν μερικοί αρκετά έμπιστοι φίλοι θα τους στείλει μία αίτηση για βοήθεια (request for assistance). Όταν αυτοί λάβουν την αίτηση θα ψάξουν τους δικούς τους φίλους και αν βρουν κάποιον ικανό και έμπιστο να βοηθήσει τότε θα αιτηθούν την υπηρεσία και θα προωθήσουν το αποτέλεσμα στον αρχικό αιτούντα. Αυτή η δυνατότητα είναι αποτέλεσμα του \textit{transative trust}%cite apo johang
 . Δηλαδή του γεγονότος ότι εάν εμπιστεύομαι κάποιον και αυτός με την σειρά του εμπιστεύεται έναν τρίτο τότε εμπιστεύομαι και εγώ τον τρίτο. Μετά την λήψη της υπηρεσίας η Ε.Ο. αποθηκεύει την ικανοποίηση της ως ικανοποίηση στον άμεσο φίλο της αφού δεν έχει ως φίλο τον τελικό πάροχο. 
\diagramscale{Transative Trust}{transative.png}{0.55}

Στο RT-IOT αυτό γενικεύεται και η αίτηση για βοήθεια έχει και ένα Time To Live (TTL) που δείχνει πόσα hops μακριά από την εικονική οντότητα μπορεί να είναι ο πάροχος. Όσο πιο μακρυά πάει τόσο πιο πιθανό είναι να βρεθεί κάποιος πάροχος, αλλά ανάλογα αυξάνει και το ρίσκο να υπάρχει κακόβουλη οντότητα στο path. Θεωρούμε πώς στο δίκτυο ισχύει η παραδοχή του six degrees of separation\footnote{
en.wikipedia.org/wiki/Six\_degrees\_of\_separation} οπότε το μέγιστο TTL είναι 6.


\begin{algorithm}
\caption{Service Request Method: Ask\_for\_assistance}
\label{Service Request 2}
\begin{algorithmic}[1]
\Procedure{Ask\textendash Assistance}{}
\State $Threshold = t$
\State $Best = 0$
\State $Trust = 0$
\For{each friend $i$ \Pisymbol{psy}{206} $Recommendation$ }
\State log\_file=get\_log\_file (Recommendation,i)
\If{size(log\_file) > 5}
\State $T_{short}=$caculate\_trust\_for\_assists(i,$\frac{size \left(log\_file\right)}{10}$)
   \Else \State $T_{short}=1.0$
   \EndIf
\State $T_{long}=$caculate\_trust\_for\_assists(i,$size \left(log file\right)$)
\State $ T = min(T_{long} \  , \  T_{short})$
\If{$T \ > \ Trust$}
	\State Best=i
	\State Trust=T
\EndIf
\EndFor
\If{ $Trust \geq threshold$}
	\State RequestAssist(Service,Best)
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
\newpage

\subsection{Μέθοδος Απόκτησης Νέων Φίλων(Friend Acquisition Method)}\label{sec:friend_acquisition}

Σε αυτή την μέθοδο , σε αντίθεση με την προηγούμενη, βασικό ρόλο παίζει ο δείκτης φήμης. Για αυτό και ή απόκτηση νέων φίλων γίνεται με 2 τρόπους. Την απόκτηση φίλων κατανεμημένα από προτάσεις φίλων και την απόκτηση φίλων από την πλατφόρμα (κεντρική αρχή). Αυτή η μέθοδος καλείται κάθε φορά που αποτυγχάνει η προηγούμενη \ref{sec:ser_req} να βρει ικανό πάροχο υπηρεσίας και μπορεί να κληθεί και κατευθείαν μετά τον βήμα 1 εάν κριθεί καλύτερο.

\subsubsection{Απόκτηση φίλων κατανεμημένα}

Εδώ μία εικονική οντότητα ενεργεί παρόμοια με τον 2ο τρόπο της προηγούμενη ενότητας. Αρχικά βρίσκει φίλους που εμπιστεύεται αρκετά για παροχή προτάσεων φίλων(recommendations). Τους κατατάσσει σε φθίνουσα σειρά εμπιστοσύνης και τους ρωτάει αν έχουν κάποια γνωστή Ε.Ο. η οποία να είναι έμπιστη για παροχή κάποιας συγκεκριμένη υπηρεσίας. Αυτό το κάνει για έναν φίλο κάθε φορά μέχρι να μαζέψει αρκετές προτάσεις.

Όταν τις μαζέψει (τις προτεινόμενες για φίλους Εικονικές Οντότητες) υπολογίζει τον δείκτη φήμης αυτών, όπως περιγράφηκε στην ενότητα \ref{sec:calculate_rep}, και κρατάει την πιο φημισμένη μαζί με την Εικονική Οντότητα που την πρότεινε. Στη συνέχεια  ζητάει την υπηρεσία που υποτίθεται ότι παρέχει καλά και αν όντως είναι αρκετά καλή την εισάγει ως φίλο στην κατάλληλη δομή από log files. Ό,τι και να γίνει αξιολογεί την αρχική Εικονική Οντότητα που έκανε την πρόταση ανάλογα με το αποτέλεσμα.

Εάν αποτύχει αυτή η μέθοδος επειδή οι φίλοι δεν μπορούσαν να βρουν προτάσεις συνεχίζει στην συγκεντρωτική μέθοδο.
\newpage


\subsubsection{Απόκτηση φίλων από την Πλατφόρμα}

Εδώ τα πράγματα είναι πολύ απλά. Όπως αναφέραμε στην ενότητα \ref{sec:calculate_rep} η πλατφόρμα έχει γνώση όλων τον εικονικών Οντοτήτων, αλλά έχει μόνο μερική εικόνα των δράσεών τους. Σε περίπτωση που της ζητηθεί πρόταση  χρησιμοποιεί το feedback που τις έχει σταλεί για να υπολογίσει τους δείκτες φήμης των εικονικών οντοτήτων και να τις κατατάξει. Στην συνέχεια θα γυρίσει κάποια ως πρόταση στον αιτούντα μαζί με τον δείκτη φήμης του και αυτός θα ζητήσει την υπηρεσία. Όμοια με πριν αν συμπεριφερθεί καλά θα τον κρατήσει ως φίλο.
 
Η ερώτηση είναι πώς επιλέγεται ο ένας που θα προταθεί;

Όπως αναφέραμε υπάρχει κάποια, αν και αρκετά απίθανη, περίπτωση να ξεγελαστεί η πλατφόρμα. Για αυτό ο τρόπος που διαλέγει να προτείνει κάποιον προσομοιώνει ένα random walk ώστε να μπορούν να αντιμετωπιστούν κακόβουλες συνεργασίες. Έτσι υπάρχει 80\% να προταθεί κάποιος από τις 3 πιο φημισμένες Ε.Ο. (ισοπίθανη επιλογή για λογους load balancing) ενώ υπάρχει και μία πιθανότητα 20\% να προταθεί κάποιος με μηδενική φήμη.

Αυτό σημαίνει πως στην περίπτωση χειραγώγησης της πλατφόρμας, όπου οι καλοί θα φαίνονται κακοί, υπάρχει 20\% πιθανότητα να προταθεί κάποιος καλός και να  κρατηθεί αυτός ως φίλος από την Εικονική Οντότητα που ζήτησε φίλους. Επίσης αυτό το 20\% βοηθάει στην ενσωμάτωση νέων Εικονικών Οντοτήτων στο σύστημα, μίας και θα έχουν μηδενική φήμη.
Σίγουρα έτσι δίνουμε μία μικρή ευκαιρία σε κακόβουλους να εκμεταλλευτούν το σύστημα αλλά θεωρούμε πώς το trade-off είναι θεμιτό.


\subsection{Μέθοδος Απόρριψης Κακόβουλων φίλων(BlackListing)}\label{sec:blacklisting}

Για να μπορέσει μία εικονική Οντότητα να διατηρήσει ένα καλό επίπεδο ικανοποίησης χρειάζεται έναν τρόπο να διαγράφει φίλους οι οποίοι είναι ή έγιναν κακόβουλοι. Αυτό πρέπει να συμβεί επειδή αλλιώς θα γέμιζε η οντότητα με κακόβουλους φίλους. Αλλά λόγω της εξασθένισης σε συνδυασμό με τον ποσοστό που υπάρχει για επιλογή τυχαίου φίλου η πιθανότητα αυτός να είναι κακόβουλος θα ήταν υψηλή.

Έτσι αποφασίστηκε οι Εικονικές Οντότητες να έχουν μία μέθοδο απόρριψης που τρέχει περιοδικά ελέγχοντας εάν η εμπιστοσύνη σε κάποιον φίλο είναι χαμηλή και τότε τον διαγράφει. Με αυτό τον τρόπο το μεγαλύτερο ποσοστό των φίλων θα είναι καλόβουλοι.
%\begin{algorithm}
%\caption{Friend Acquisition Method: Distributed}
%\label{distributed friends}
%\begin{algorithmic}[1]
%\Procedure{Distributed\textendash Friend\textendash Acquistion}{}
%\State Priorirty Queue A =  Rank_friends(Recommending)
%\while


%\For{each friend $i$ \Pisymbol{psy}{206} $Service$ }
%\If{size(log file) > 5}
%\State $T_{short}=$caculate Trust(i,$\frac{size \left(log file\right)}{10}$)
%   \Else \State $T_{short}=1.0$
 %  \EndIf
%\State $T_{long}=$caculate Trust(i,$size \left(log file\right)$)
%\State $ T = min(T_{long} \  , \  T_{short})$
%\If{$T \ > \ Trust$}
%	\State Best=i
%	\State Trust=T
%\EndIf
%\EndFor
%\If{ $Trust \geq threshold$}
%	\State RequestService(Service,Best)
%	\Else 
%	\If{$\left(threshold \  indicates\  low\  severity\right)\  AND\ \left( Math.random() \leq 0.1\right)$}
%			\State RequestService(Service,Random friend with zero trust)
%	\EndIf
%\EndIf

%\EndProcedure
%\end{algorithmic}
%\end{algorithm}
